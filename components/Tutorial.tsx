import React, { useState, useEffect } from 'react';

interface TutorialProps {
  onFinish: () => void;
  onStartDummyLeadGeneration: () => void;
  onOpenModal: () => void;
}

const tutorialSteps = [
  {
    targetId: 'target-location-input',
    title: 'Start Here: Target Location',
    content: 'Begin by entering the city or region where you want to find business leads.',
    position: 'bottom',
  },
  {
    targetId: 'customResearchType',
    title: 'Define Your Research Focus',
    content: 'Next, choose what specific information the AI should look for. This helps tailor the results to your needs.',
    position: 'bottom',
  },
  {
    targetId: 'generate-leads-button',
    title: 'Generate Your Leads',
    content: "Once you're ready, click this button. For the tutorial, this will simulate the generation process and show you a pre-made example.",
    position: 'top',
  },
  {
    targetId: 'loading-display-container',
    title: 'AI is Researching...',
    content: 'The AI is now finding companies, researching details, and writing messages. This usually takes a moment.',
    position: 'top',
    action: 'startDummyLeadGeneration',
  },
  {
    targetId: 'results-display-container',
    title: 'Your Leads are Ready!',
    content: 'Here are the leads generated by the AI, complete with contact info, research findings, and draft messages.',
    position: 'top',
  },
  {
    targetId: 'tutorial-save-button',
    title: 'Save Your Leads',
    content: 'Click "Save" to keep a lead. This prevents the AI from generating it again, helping you find new opportunities each time.',
    position: 'bottom',
  },
  {
    targetId: 'saved-leads-button',
    title: 'View Saved Data',
    content: 'Your saved leads and other data can be accessed here at any time.',
    position: 'bottom',
  },
  {
    targetId: 'export-csv-button',
    title: 'Export Your Data',
    content: 'You can export all of your saved leads into a CSV file for use in Excel or Google Sheets.',
    position: 'bottom',
    action: 'openModal',
  },
];


const Tutorial: React.FC<TutorialProps> = ({ onFinish, onStartDummyLeadGeneration, onOpenModal }) => {
  const [step, setStep] = useState(0);
  const [isOpen, setIsOpen] = useState(false);
  const [tooltipStyle, setTooltipStyle] = useState<React.CSSProperties>({ display: 'none' });
  const [arrowStyle, setArrowStyle] = useState<React.CSSProperties>({ display: 'none' });

  useEffect(() => {
    const hasSeenTutorial = localStorage.getItem('hasSeenTutorial');
    if (hasSeenTutorial !== 'true') {
      setIsOpen(true);
    }
  }, []);

  useEffect(() => {
    if (!isOpen) return;

    const currentStepData = tutorialSteps[step];
    if (currentStepData.action === 'startDummyLeadGeneration') {
      onStartDummyLeadGeneration();
    }
    if (currentStepData.action === 'openModal') {
      onOpenModal();
    }

    let lastHighlightedElement: HTMLElement | null = null;
    
    const positionTooltip = (targetElement: HTMLElement) => {
        lastHighlightedElement = targetElement;
        // Apply highlight styles directly to the element
        targetElement.style.zIndex = '1001';
        targetElement.style.position = 'relative';
        targetElement.style.boxShadow = '0 0 0 4px rgba(98, 155, 188, 0.7)';
        targetElement.style.borderRadius = '6px';
        targetElement.style.transition = 'box-shadow 0.3s ease-in-out';
        
        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // This timeout waits for the smooth scroll animation to finish
        setTimeout(() => {
            requestAnimationFrame(() => {
                const targetRect = targetElement.getBoundingClientRect();
                const tooltipWidth = 300;
                let left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
                left = Math.max(10, Math.min(left, window.innerWidth - tooltipWidth - 10));

                const newTooltipStyle: React.CSSProperties = {
                  position: 'fixed', left: `${left}px`, width: `${tooltipWidth}px`, zIndex: 1002, display: 'block',
                };
                const newArrowStyle: React.CSSProperties = {
                    position: 'absolute', left: `${targetRect.left + (targetRect.width / 2) - left - 6}px`, width: 0, height: 0,
                    borderLeft: '6px solid transparent', borderRight: '6px solid transparent',
                };

                if (currentStepData.position === 'bottom') {
                  newTooltipStyle.top = `${targetRect.bottom + 12}px`;
                  newArrowStyle.bottom = '100%';
                  newArrowStyle.borderBottom = '6px solid white';
                } else {
                  newTooltipStyle.top = `${targetRect.top - 12}px`;
                  newTooltipStyle.transform = 'translateY(-100%)';
                  newArrowStyle.top = '100%';
                  newArrowStyle.borderTop = '6px solid white';
                }
                setTooltipStyle(newTooltipStyle);
                setArrowStyle(newArrowStyle);
            });
        }, 400);
    };

    // This interval checks repeatedly for the element, which is more reliable
    const interval = setInterval(() => {
      const targetElement = document.getElementById(currentStepData.targetId);
      if (targetElement) {
        clearInterval(interval);
        positionTooltip(targetElement);
      }
    }, 100);

    return () => {
      clearInterval(interval);
      if (lastHighlightedElement) {
        // Remove the highlight styles
        lastHighlightedElement.style.zIndex = '';
        lastHighlightedElement.style.position = '';
        lastHighlightedElement.style.boxShadow = '';
        lastHighlightedElement.style.borderRadius = '';
        lastHighlightedElement.style.transition = '';
      }
    };
  }, [isOpen, step, onStartDummyLeadGeneration, onOpenModal]);

  const endTutorial = () => {
    localStorage.setItem('hasSeenTutorial', 'true');
    setIsOpen(false);
    onFinish();
  };

  const handleNext = () => {
    setTooltipStyle({ display: 'none' });
    if (step < tutorialSteps.length - 1) {
      setStep(step + 1);
    } else {
      endTutorial();
    }
  };

  const handleSkip = () => {
    setTooltipStyle({ display: 'none' });
    endTutorial();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-[1000] bg-black bg-opacity-70">
      <div style={tooltipStyle} className="bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl p-4 animate-fade-in relative">
        <div style={arrowStyle} />
        <h3 className="font-heading font-bold text-lg mb-2 text-text-primary-light dark:text-text-primary-dark">{tutorialSteps[step].title}</h3>
        <p className="text-sm text-text-secondary-light dark:text-text-secondary-dark">{tutorialSteps[step].content}</p>
        <div className="flex justify-between items-center mt-4">
          <span className="text-xs text-text-secondary-dark">{step + 1} / {tutorialSteps.length}</span>
          <div>
            <button onClick={handleSkip} className="text-sm text-text-secondary-light hover:text-text-primary-light dark:hover:text-text-secondary-dark mr-4">Skip</button>
            <button
              onClick={handleNext}
              className="px-4 py-2 bg-primary-light hover:brightness-95 dark:bg-primary-dark dark:hover:brightness-95 text-white font-semibold rounded-md text-sm transition-colors duration-200"
            >
              {step === tutorialSteps.length - 1 ? 'Finish' : 'Next'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Tutorial;